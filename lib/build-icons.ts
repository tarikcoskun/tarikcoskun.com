import fs from "node:fs/promises"
import path from "node:path"
import { $ } from "execa"
import { glob } from "glob"

const cwd = process.cwd()
const iconsDir = path.join(cwd, "assets", "icons")
const publicDir = path.join(cwd, "public")
const componentDir = path.join(cwd, "src", "components", "Icon")

const isForced = process.argv.includes("--force")
const isVerbose = !process.argv.includes("--silent")
const log = isVerbose ? console.log : () => {}

async function main() {
	const libraries = await fs.readdir(iconsDir)

	const allFiles: string[] = []
	const allIconList: string[] = []

	if (libraries.length === 0) {
		console.log(`No icon libraries found in ${path.relative(cwd, iconsDir)}`)
		return
	}

	for (const library of libraries) {
		const inputDir = path.join(iconsDir, library)
		const files = glob.sync("**/*.svg", { cwd: inputDir }).sort((a, b) => a.localeCompare(b))

		if (files.length === 0) {
			console.log(`No SVG files found in ${path.relative(cwd, inputDir)}`)
			continue
		}

		allFiles.push(...files.map((file) => path.join(inputDir, file)))
		allIconList.push(...files.map((file) => `${library}:${file.replace(/\.svg$/, "")}`))
	}

	if (allFiles.length === 0) {
		console.log("No SVG files found in any library.")
		return
	}

	await generateIconFiles({ files: allFiles, iconList: allIconList })
}

async function generateIconFiles({ files, iconList }: { files: string[]; iconList: string[] }) {
	const typeFilePath = path.join(componentDir, "icon-list.ts")
	const spriteFilePath = path.join(publicDir, "sprite.svg")

	const currentTypes = await fs.readFile(typeFilePath, "utf8").catch(() => "")
	const currentSprite = await fs.readFile(spriteFilePath, "utf8").catch(() => "")

	const typesUpToDate = iconList.every((name) => currentTypes.includes(`"${name}"`))
	const spriteUpToDate = iconList.every((name) => currentSprite.includes(`id="${name}"`))

	if (!isForced && typesUpToDate && spriteUpToDate) {
		log("Icons are up to date")
		return
	}

	log("Generating sprite...")

	const spriteChanged = await generateSvgSprite({
		files,
		iconList,
		outputPath: spriteFilePath,
	})

	for (let i = 0; i < files.length; i++) {
		const file = files[i]
		const library = path.basename(path.dirname(file))
		log(`âœ“ ${library}:${path.basename(file)}`)
	}

	log(`Saved to ${path.relative(cwd, spriteFilePath)}`)

	const stringifiedIconNames = iconList.map((name) => JSON.stringify(name))

	const typeOutputContent = `
  // This file is generated by bun run build:icons

  export type IconList =
    \t| ${stringifiedIconNames.join("\n\t| ")}
  `

	const typesChanged = await writeIfChanged(typeFilePath, typeOutputContent)

	log(`Manifest saved to ${path.relative(cwd, typeFilePath)}`)

	if (spriteChanged || typesChanged) {
		console.log(`Generated ${files.length} icons`)
	}
}

async function generateSvgSprite({
	files,
	iconList,
	outputPath,
}: {
	files: string[]
	iconList: string[]
	outputPath: string
}) {
	const symbols = await Promise.all(
		files.map(async (file, idx) => {
			const input = await fs.readFile(file, "utf8")

			const svgContentMatch = input.match(/<svg[^>]*>([\s\S]*?)<\/svg>/i)
			if (!svgContentMatch || !svgContentMatch[1]) {
				throw new Error(`No SVG content found in ${file}`)
			}

			const viewBoxMatch = input.match(/viewBox="([^"]*)"/i)
			if (!viewBoxMatch || !viewBoxMatch[1]) {
				throw new Error(`No viewBox attribute found in ${file}`)
			}

			return `<symbol viewBox="${viewBoxMatch[1]}" id="${iconList[idx]}">${svgContentMatch[1]}</symbol>`
		}),
	)

	const output = [
		`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
		"<defs>",
		...symbols,
		"</defs>",
		"</svg>",
		"", // trailing newline
	].join("\n")

	return writeIfChanged(outputPath, output)
}

async function writeIfChanged(filePath: string, newContent: string) {
	const currentContent = await fs.readFile(filePath, "utf8").catch(() => "")
	if (currentContent === newContent) return false
	await fs.writeFile(filePath, newContent, "utf8")
	await $`prettier --write ${filePath} --ignore-unknown`
	return true
}

main()
