import { spawn } from "node:child_process"
import fs from "node:fs/promises"
import path from "node:path"

const isForced = process.argv.includes("--force")
const isVerbose = !process.argv.includes("--silent")
const log = isVerbose ? console.log : () => {}

const cwd = process.cwd()
const iconsDir = path.join(cwd, "assets", "icons")
const spriteFilePath = path.join(cwd, "public", "sprite.svg")
const typeFilePath = path.join(cwd, "src", "types", "icon-list.ts")

async function main() {
	const libraries = await fs.readdir(iconsDir)

	const allFiles: string[] = []
	const allIconList: string[] = []

	if (libraries.length === 0) {
		console.log(`No icon libraries found in ${path.relative(cwd, iconsDir)}`)
		return
	}

	for (const library of libraries) {
		const inputDir = path.join(iconsDir, library)
		const files = (await fs.readdir(inputDir)).sort((a, b) => a.localeCompare(b))

		if (files.length === 0) {
			console.log(`No SVG files found in ${path.relative(cwd, inputDir)}`)
			continue
		}

		allFiles.push(...files.map((file) => path.join(inputDir, file)))
		allIconList.push(...files.map((file) => `${library}:${file.replace(/\.svg$/, "")}`))
	}

	if (allFiles.length === 0) {
		console.log("No SVG files found in any library.")
		return
	}

	await generateIconFiles({ files: allFiles, iconList: allIconList })
}

async function generateIconFiles({ files, iconList }: { files: string[]; iconList: string[] }) {
	const currentTypes = await fs.readFile(typeFilePath, "utf8").catch(() => "")
	const currentSprite = await fs.readFile(spriteFilePath, "utf8").catch(() => "")

	const typesUpToDate = iconList.every((name) => currentTypes.includes(`"${name}"`))
	const spriteUpToDate = iconList.every((name) => currentSprite.includes(`id="${name}"`))

	if (!isForced && typesUpToDate && spriteUpToDate) {
		log("Icons are up to date")
		return
	}

	log("Generating sprite...")

	const spriteChanged = await generateSvgSprite({
		files,
		iconList,
		outputPath: spriteFilePath,
	})

	for (let i = 0; i < files.length; i++) {
		const file = files[i]
		const library = path.basename(path.dirname(file))
		log(`âœ“ ${library}:${path.basename(file)}`)
	}

	log(`Saved to ${path.relative(cwd, spriteFilePath)}`)

	const stringifiedIconNames = iconList.map((name) => JSON.stringify(name))

	const typeOutputContent = `
  // This file is generated by bun run build:icons

  export type IconList =
    \t| ${stringifiedIconNames.join("\n\t| ")}
  `

	const typesChanged = await writeIfChanged(typeFilePath, typeOutputContent)

	log(`Manifest saved to ${path.relative(cwd, typeFilePath)}`)

	if (spriteChanged || typesChanged) {
		console.log(`Generated ${files.length} icons`)
	}
}

async function generateSvgSprite({
	files,
	iconList,
	outputPath,
}: {
	files: string[]
	iconList: string[]
	outputPath: string
}) {
	const symbols = await Promise.all(
		files.map(async (file, idx) => {
			const input = await fs.readFile(file, "utf8")
			const isColored = input.includes("<!-- preserve colors -->")

			const svgContentMatch = input.match(/<svg[^>]*>([\s\S]*?)<\/svg>/i)
			if (!svgContentMatch || !svgContentMatch[1]) {
				throw new Error(`No SVG content found in ${file}`)
			}

			const viewBoxMatch = input.match(/viewBox="([^"]*)"/i)
			if (!viewBoxMatch || !viewBoxMatch[1]) {
				throw new Error(`No viewBox attribute found in ${file}`)
			}

			const viewBox = viewBoxMatch[1]
			const svgContent = isColored
				? svgContentMatch[1]
				: svgContentMatch[1].replace(/fill="([^"]*)"/g, "")
			return `<symbol viewBox="${viewBox}" id="${iconList[idx]}">${svgContent}</symbol>`
		}),
	)

	const output = [
		`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
		"<defs>",
		...symbols,
		"</defs>",
		"</svg>",
		"", // trailing newline
	].join("\n")

	return writeIfChanged(outputPath, output)
}

async function writeIfChanged(filePath: string, newContent: string) {
	const currentContent = await fs.readFile(filePath, "utf8").catch(() => "")
	if (currentContent === newContent) return false

	await fs.writeFile(filePath, newContent, "utf8")

	const prettierProcess = spawn("prettier", ["--write", filePath, "--ignore-unknown"])

	return new Promise<boolean>((resolve, reject) => {
		prettierProcess.on("close", (code) => {
			if (code === 0) {
				resolve(true)
			} else {
				reject(new Error(`Prettier exited with code ${code}`))
			}
		})

		prettierProcess.on("error", (err) => {
			reject(new Error(`Failed to start Prettier process: ${err.message}`))
		})
	})
}

main()
